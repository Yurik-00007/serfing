В html есть 2 вида тегов блочный и строчные проще запомнить строчные такие как картинка-img, ссылка, span
и те файлы которые входят в форму это input, select, textarea. Теги могут быть как самозакрывающиеся так и одиночные

--------------------------------места css--------------------------------------------------

Каскаднная таблицы стилей css можно писать в 3 разных местах

1. inline стили когда пишется прямо в строку (❗имеют наивысший приоритет)
   <h5 style="text-align: center; color:tomato;">Привет!</h5>
2. когда пишется в тег после тега <body>

<style>
p{ text-align: center; }
</style>

3. И самый правильный и распространенный когда пишется в отдельный файл в теги <header>
    <link rel="stylesheet" href="css/style.css">

--------------------------------селектор--------------------------------------------------

1. Использование классов в HTML позволяет легко и эффективно применять одинаковые стили ко множеству элементов на
   веб-странице.
   Класс это имя которое используется в css в качестве селектора, но только с точкой(селектор класса).
   <span class="content">Lorem ipsum dolor sit amet, consectetur adipisicing elit. Ad, quos.</span> -html

<div class="content">Lorem ipsum dolor sit amet, consectetur adipisicing elit. Ad, quos.</div> - html
.content{ font-size: 35px; } - css

2. Так же бывает селектор тега
   <h3>Привет!</h3> - html
   h3{ text-align: center; color:tomato; } - css
3. Так же бывает селектор идентификатора

<p id="text1">lorem </p> - html
    #text1{ font-style: italic; } -css

--------------------------------стили по умолчанию--------------------------------------------------

1. Стили по умолчанию нужно сбрасывать для этого есть сайт, где все это указано
   http://html5doctor.com/html-5-reset-stylesheet/
2. Создается отдельный файл(reset.css) и туда все это добро записывается
3. Важно помнить о приоритетности когда подключаем свои стили(style.css) он должны быть в конце тогда приоритет будет -
   выше
4. А reset.css должен быть выше тогда приоритет - ниже
    <link rel="stylesheet" href="css/reset.css">
    <link rel="stylesheet" href="css/style.css">

--------------------------------Схлопывание отступов margin--------------------------------------------------

Схлопывание отступов (margin collapsing) — это особенность CSS, которая влияет на вертикальные отступы (margin) между
блоками. Эта особенность заключается в том, что когда два вертикальных отступа встречаются, они "схлопываются" в один,
равный наибольшему из отступов, а не суммируются.

--------------------------------отрицательное значение margin--------------------------------------------------

Когда у свойства margin в CSS есть отрицательное значение, это означает, что соответствующий элемент будет перемещаться
в противоположном направлении, по сравнению с положительным значением отступа.
margin-top: -87px;

--------------------------------горизонтального центрирования блока margin: 0
auto--------------------------------------------------

Свойство margin: 0 auto; часто используется для горизонтального центрирования блока (обёртки) внутри его родительского
контейнера.

--------------------------------размеров элемента box-sizing:
border-box--------------------------------------------------

Свойство box-sizing: border-box; в CSS изменяет модель расчета размеров элемента. Это свойство определяет, как
вычисляются размеры элемента, включая его ширину и высоту.
В этом режиме размеры элемента включают области содержимого, внутренние отступы и границы.
Указанные размеры элемента являются его общими размерами (ширина и высота). А контент сужается, чтобы соответствовать.
Записывается общие стили.
пример:
*{ box-sizing: border-box; }

--------------------------------отображением содержания overflow:
hidden--------------------------------------------------

Свойство overflow управляет отображением содержания блочного элемента, если оно целиком не помещается и выходит за
область заданных размеров.
overflow: auto | hidden | scroll | visible-по умолчанию

hidden
Отображается только область внутри элемента, остальное будет скрыто.
auto
Полосы прокрутки добавляются только при необходимости.

---------------------------------------------Псевдоклассы ---------------------------------------------

Псевдокласс в CSS — это ключевое слово, добавленное к селектору, которое определяет его особое состояние.
Псевдоклассы:

1. :active-> Когда пользователь нажимает на элемент.
2. :hover-> Когда указатель мыши находится над элементом.
3. :focus->При навигации с помощью клавиатуры или клике на элемент.
4. :first-child-> Этот псевдокласс применяется к первому дочернему элементу родителя.
5. :last-child->Этот псевдокласс применяется к последнему дочернему элементу родителя
6. :nth-child(n/odd/even)->Этот псевдокласс применяется к элементам на основе их позиции в группе братских элементов.
7. :nth-of-type(n)->Этот псевдокласс работает аналогично :nth-child, но учитывает только элементы определенного типа.
8. :required->то есть обязательные для заполнения,
9. :checked->Этот псевдокласс применяется к элементам типа чекбоксов или радиокнопок, которые выбраны (отмечены),
10. :disabled-> Этот псевдокласс применяется к элементам, которые отключены (неактивны).
11. :not()->Этот псевдокласс выбирает элементы, которые не соответствуют указанному селектору.

    ---------------------------------------------Псевдоэлементы ---------------------------------------------

Псевдоэлемент в CSS — это ключевое слово, добавляемое к селектору, которое позволяет стилизовать определённую часть
выбранного элемента. Псевдоэлементобязательно должен содержать content: '' и display: inline-block;

	Псевдоэлементы:
		1. ::before
		Псевдоэлемент before вставляет текст перед элементом. Используется только совместно со свойством content,
		которое задает текст, который следует вставить. И display: inline-block; который говорит что объект должен иметь
		область видимости
		2. ::after
		3. ::placeholder

пример:
.title-1:hover::before {
content: '';
width: 30px;
height: 30px;
border-radius: 50%;
background: #000;
top: 50px;
left: 490px;
position: absolute;
}

---------------------------------------------Позиционирование(position) ---------------------------------------------

position: static/relative/absolute/fixed;
top, left, right, bottom
В CSS свойства position и top, left, right, bottom используются для управления расположением элементов на веб-странице.

1. position: static - значение по умолчанию. Элементы с position: static расположены в нормальном потоке документа.
   Свойства top, left, right, bottom для них не применяются.
2. position: relative - элемент с position: relative располагается относительно своего обычного положения. Свойства
   top, left, right, bottom смещают элемент относительно его нормального положения.
3. position: absolute - элемент с position: absolute позиционируется относительно ближайшего предка с position:
   relative,
   position: absolute или position: fixed. Если такого предка нет, то относительно начального контекста (обычно
   это <html>).
4. position: fixed - элемент с position: fixed позиционируется относительно окна браузера и остается на месте даже
   при прокрутке страницы.
5. position: sticky - элемент с position: sticky в CSS используется для создания "липкого" позиционирования элементов,
   при котором элемент ведет себя как relative до тех пор, пока не достигает заданного порога (обычно верхнего или
   нижнего
   края родительского элемента или окна браузера), после чего он ведет себя как fixed.

   ---------------------------------------------Позиционирование(z-index) ---------------------------------------------

z-index - cвойство устанавливает, кто будет сверху в случае, если несколько элементов накладываются друг на друга.
Любые позиционированные элементы на веб-странице могут накладываться друг на друга в определенном порядке, имитируя тем
самым третье измерение, перпендикулярное экрану. Каждый элемент может находиться как ниже, так и выше других объектов
веб-страницы, их размещением по z-оси и управляет z-index. Это свойство работает только для элементов, у которых
значение
position задано как absolute, fixed или relative.

---------------------------------------------Трансформирует(transform) ---------------------------------------------

Трансформирует элемент, в частности, позволяет его масштабировать, вращать, сдвигать, наклонять, а также комбинировать
виды трансформаций, перечисляя функции трансформации через пробел.

transform-origin-Устанавливает координаты точки, относительно которой будет происходить трансформация элемента.

Функции трансформации:

rotate()-Поворачивает элемент в двумерном пространстве на заданный угол относительно точки трансформации, задаваемой
свойством transform-origin.

scale()-Масштабирует элемент по горизонтали и вертикали.

translate()-Сдвигает элемент на заданное значение по горизонтали и вертикали.

translateX()-Сдвигает элемент по горизонтали на указанное значение. Положительное значение сдвигает вправо,
отрицательное влево.

translateY()-Сдвигает элемент по вертикали на указанное значение. Положительное значение сдвигает вниз, отрицательное
вверх.

translateZ()-Сдвигает элемент по оси Z на указанное значение. Положительное значение сдвигает вперёд, отрицательное
назад.

Первоначально нужно задать начальные значения для transform и transform-origin(если нужно вращать) в классе и задать
animation с именем и параметрами, а потом задать @keyframes с именем и конечными значениями transform

Пример
.circle {
transform: rotate(0deg);
transform-origin: top left;
animation:5s ease .5s forwards infinite alternate translateX;
}

@keyframes translateX {
50% {
transform: rotate(360deg) translate(100px) scale(2);
}
100%{
transform: rotate(720deg) translate(0px) scale(1);
}
}

---------------------------------------------Преобразует(transition) ---------------------------------------------

В классе указывается transition а в псевдоклассе(:hover) или медиа-запросе укрываются свойства которые нужно изменить
Для того чтобы сработал transition нужно чтобы были какит-о числовые значения
.container {
width: 500px;
height: 500px;
background: tomato;
transition: font-size 1.5s linear .5s;
}
transition:  font-size 1.5s linear .5s;
свойства=all длительность=0s скорость=ease анимации=0s
property duration timing-function delay

transition можно использовать с псевдоклассами и с медиа-запросами

Универсальное свойство, которое позволяет одновременно задать значения transition-property, transition-duration,
transition-timing-function и transition-delay.

Устанавливает эффект перехода между двумя состояниями элемента, они могут быть определены с помощью псевдокласса
:hover или :active, а также динамически через JavaScript.

1.Свойство transition-delay устанавливает время ожидания перед запуском эффекта перехода.

2.Свойство transition-property устанавливает имя стилевого свойства, значение которого будет отслеживаться для
создания эффекта перехода.

3.Свойство transition-duration задаёт время в секундах или миллисекундах, сколько должна длиться анимация перехода
до её завершения.

4.Свойство transition-timing-function устанавливает, насколько быстро должно изменяться значение стилевого свойство
для которого применяется эффект перехода.

.container:hover {
background: green;
font-size: 26px;
color: white;
}

@media (max-width: 800px) {
.container {
background: yellow;
}
}
----------------------------------------------------------flex----------------------------------------------------------
display:flex ->размечает контейнер для его элементов

Свойства которые применяются непосредственно к flex-контейнеру⬇️:

flex-direction-->Свойство устанавливает направление главной и поперечной оси или, говоря другими словами, расставляет
элементы в ряд или в колонку.
Синтаксис
селектор {
flex-direction: row | row-reverse | column | column-reverse;}

row-->Главная ось направлена слева направо. Элементы расположены в ряд, по умолчанию прижаты к левому краю, их нумерация
имеет
обычный порядок - слева направо.
row-reverse-->Главная ось направлена справа налево. Элементы расположены в ряд, по умолчанию прижаты к правому краю, их
нумерация имеет обратный порядок - справа налево.
column-->Главная ось направлена сверху вниз. Элементы расположены в колонку, по умолчанию прижаты к верху, их нумерация
имеет обычный порядок - сверху вниз.
column-reverse-->Главная ось направлена снизу вверх. Элементы расположены в колонку, по умолчанию прижаты к низу, их
нумерация имеет обратный порядок - снизу вверх.

justify-content->Определяет, как браузер распределяет пространство вокруг флекс-элементов вдоль главной оси контейнера.
Синтаксис
селектор {
justify-content: flex-start | flex-end | center | space-between |
space-around | space-evenly}

flex-start->Флексы прижаты к началу строки.
flex-end -> Флексы прижаты к концу строки.
center -> Флексы выравниваются по центру строки.
space-between -> Флексы равномерно распределяются по всей строке. Первый и последний элемент прижимаются к
соответствующим краям контейнера.
space-around -> Флексы равномерно распределяются по всей строке. Пустое пространство перед первым и после последнего
элементов равно половине пространства между двумя соседними элементами.
space-evenly -> Флексы распределяются так, что расстояние между любыми двумя соседними элементами, а также перед первым
и после последнего, было одинаковым.

Свойство align-items выравнивает флекс-элементы внутри контейнера вдоль второстепенной оси направлении.
Синтаксис
селектор {
align-items: flex-start | flex-end | center | baseline | stretch}

stretch->Флексы растягиваются таким образом, чтобы занять всё доступное пространство контейнера.
baseline->Флексы выравниваются по их базовой линии(верхняя строка низ у всех flex-элементов).

flex-wrap - cвойство задает многострочную расстановку блоков по главной оси. Применяется к родительскому элементу для
flex
блоков. Входит в свойство-сокращение flex-flow.
Синтаксис
селектор {
flex-wrap: nowrap | wrap | wrap-reverse;}

nowrap-->Однострочный режим - блоки выстраиваются в одну строку.
wrap-->Блоки выстраиваются в несколько строк, если не помещаются в одну.
wrap-->reverse То же самое, что и wrap, но блоки выстраиваются в другом порядке (сначала последний, потом первый).

align-content - свойство задает выравнивание элементов вдоль поперечной оси для flex блоков и по горизонтальной оси для
гридов. Применяется к родительскому элементу. Если у нас более одной строки с элементомами то это свойство можно
применять.
Оно выравнит строки с элементами в кантейнере.
Синтаксис
селектор {
align-content: flex-start | flex-end | center | space-between | space-around;}

flex-start-->Блоки прижаты к началу поперечной (вертикальной) оси.
flex-end-->Блоки прижаты к концу поперечной (вертикальной) оси.
center-->Блоки стоят по центру поперечной (вертикальной) оси.
space-between-->Блоки распределены вдоль поперечной (вертикальной) оси, при этом первый элемент прижат к началу оси, а
последний - к концу.
space-around-->Блоки распределены вдоль поперечной (вертикальной) оси, при этом между первым блоком и началом оси,
последним блоком и концом оси такой же промежуток, как и между остальными блоками.
Однако, они не равны, как могло бы показаться: промежутки суммируются и между двумя блоками расстояние в два раза
больше, чем между блоком и началом/концом оси.

Свойства которые применяются непосредственно к flex-элементу⬇️:

align-self - Свойство align-self задает выравнивание вдоль поперечной оси для отдельно взятого flex-блока и по
вертикальной оси для отдельного элемента в флекс. По сути данное свойство представляет собой свойство align-items,
но для конкретного блока.
Синтаксис
селектор {
align-self: auto | flex-start | flex-end | center | baseline | stretch;}

flex-start-->Блоки прижаты к началу поперечной (вертикальной) оси.
flex-end-->Блоки прижаты к концу поперечной (вертикальной) оси.
center-->Блоки стоят по центру поперечной (вертикальной) оси.
space-between-->Блок выравнивается по своей базовой линии. Базовая линия (англ. baseline, или линия шрифта) - это
воображаемая линия, проходящая по нижнему краю символов без учета свисаний, например, как у букв 'ц', 'д', 'р', 'щ'.
stretch-->Блок растянут, занимая все доступное место по поперечной оси, при этом все же учитываются min-width и
max-width,
если они заданы. Если же задана ширина и высота для элемента - stretch будет проигнорирован.
auto-->Блок будет выровнен так, как задано в свойстве align-items.

order - cвойство задает порядок следования отдельно взятого flex-блока(элемента) внутри flex-контейнера.
Применяется к конкретному flex блоку. Своим значением свойство принимает положительное или отрицательное целое число.
Чем меньше число - тем раньше будет стоять элемент, независимо от расположения в HTML коде относительно других
элементов.

margin:0 auto;
Это свойство позволяет центрировать элемент отнасительно контейнера. можно сравнить с justify-content:center;
Только justify-content -это для flex-контейнера, margin:0 auto;-для flex-элемента

свойства которые применяются на родителя: display:flex,justify-content,align-items,align-content
свойства которые применяются на детей: align-self, order,flex-basis, flex-shrink,

================flex-basis, flex-grow, flex-shrink. flexbox погружение======================
https://www.youtube.com/watch?v=QuAVrIRjkjE

flex-grow(по ширине) - свойство определяет каэфициент растяжения свободного прастранства того, на сколько отдельный
flex-блок может быть больше соседних элементов, если это необходимо.
flex-grow:0->по умолчанию

https://code.mu/ru/markup/manual/css/property/flex-grow/

1.Если у элементов не задан размкер а задан только flex-grow, они распределяться равномерно отнасилельно значению
контейнера(width:900)
и элементов первого(flex-grow: 1;) и второго(flex-grow: 2;). В этом случае ширина обшего контейнера(900) поделиться
на 3 части и каждому достанеться по соответствующему значению: первому(1*300=300) и второму(2*300=600)

2.Если суммарная ширина элементов меньше ширины родителя, поэтому справа остается пустое пространство. При желании это
пустое пространство можно пропорционально разделить между нашими элементами. Это делается с помощью свойства flex-grow,
задаваемого флекс-элементам. Как это будет выглядить. Размер ширины контейнера 1000px, а размер первого и второго
flex-элемента по 200px, значит у нас образуеться пустое пространство равное 500px, его можно поделить при использование
к каждому элементу flex-grow: к первому flex-grow: 1;ко второму flex-grow: 2;. И тогда свободное пространство делиться
на 3 части и добовляеться к каждому элементу:600/3=200 первый-->200(его размер)+(200*1)=400 и
второй 200(его размер)+(200*2)=600

3.Если контент забрал все свободное место то писать flex-grow бесполезно так как он не будет работать

flex-shrink - cвойство определяет коэфициент сжатия того, насколько flex-блок(элемент) будет уменьшаться относительно
соседних элементов внутри flex-контейнера в случае недостатка свободного места.
flex-shrink:1->по умолчанию
flex-shrink:0-->flex-блок(элемент) не будет изменять размер присжатие экрана
https://code.mu/ru/markup/manual/css/property/flex-shrink/

flex-basis - свойство задает размер элемента вдоль главной оси. Это значит, что если главная ось горизонтальна - это
свойство будет задавать ширину элементов, а если вертикальна - то высоту.
flex-basis имеет приоритет над width но приоритет у него ниже чем у min-width и max-width
https://code.mu/ru/markup/manual/css/property/flex-basis/

shortcut(сокращение)
Свойство flex сокращение для flex-grow, flex-shrink и flex-basis.
https://developer.mozilla.org/ru/docs/Web/CSS/flex#%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%81

Пример:
flex:0 1 auto;-->по умолчанию
можно расписать так
flex-grow:0;
flex-shrink:1;
flex-basis:auto;

0 0 auto
flex: none;

Одно значение, число без единиц: flex-grow->всегда первое, если нет единиц
flex: 2;

---------------------------------------------Когда подключать script(
main.js)?-------------------------------------------

Скрипт нужно подключать перед закрывающим тегом body для того чтобы отработала страница html, а потом загрузился код JS.
Внутр тега <script> подключат ничего не нужно - этот код не сработает.

пример:
<script src="./js/main.js">
</script>
.</body>

---------------------------------------------как подключать jquery?-------------------------------------------
jquery должен быть подключён самым первым среди всех скрипров. jquery можно подключать несколькими способами:

1. Пойти не посредственно на сайт и скачать
   https://code.jquery.com/jquery-3.7.1.min.js
   и установить его самым первым среди всех тегов <script>

<script src="./js/jquery-3.7.1.min.js"></script>

2. Можно подключить jquery используя google cdn:
   https://developers.google.com/speed/libraries
   и там в первом абзаце есть как прописать тег <script>, не забывайте что установить его самым первым среди всех
   тегов <script>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>

---------------------------------------------Селектор по атрибуту-------------------------------------------

Селектор по атрибуту находит элемент на странице по значению либо по наличию атрибута.

Пример Скопировать ссылку "Пример"
<blockquote cite="А. С. Пушкин">
  Октябрь уж наступил — уж роща отряхает<br>
  Последние листы с нагих своих ветвей;
</blockquote>

Скопировать
Селектор ниже найдёт все цитаты (<blockquote>) с атрибутом cite:

blockquote[cite] {
background-color: #2E9AFF;
}

---------------------------------------------Селектор по атрибуту-------------------------------------------
🚩Свойство background-image задает фоновую картинку элементу. По умолчанию картинка замостит своими копиями весь блок,
однако, это поведение можно отменить с помощью свойства background-repeat.
селектор {
background-image: url(путь к картинке);
}
селектор {
background-image: none;->по умолчанию
}
url - Путь к файлу с картинкой. Название картинки может быть в двойных кавычках, одинарных и вообще без кавычек.
none - Отменяет фоновую картинку для элемента.

🚩Свойство background-repeat задает каким образом повторять фоновую картинку элемента. По умолчанию картинка повторяется
и по оси X, и по оси Y, таким образом покрывая собой всю доступную область.

селектор {
background-repeat: no-repeat | repeat-x | repeat-y | space | round | repeat ->по умолчанию;
}
no-repeat Картинка не будет повторяться вообще.
repeat-x Картинка будет повторяться по оси X.
repeat-y Картинка будет повторяться по оси Y.
repeat Картинка будет повторяться по оси X и по оси Y.
space Картинка повторится столько раз, чтобы полностью заполнить область, если это не удается, между картинками
добавляется пустое пространство.
round Картинка повторится так, чтобы в области поместилось целое число рисунков, если это не удается сделать, то фоновые
рисунки масштабируются.

🚩Свойство background-position задает местоположение фоновой картинки элемента. Местоположение можно задавать с помощью
любых единиц для размеров. Первое значение обозначает отступ слева, второе - отступ сверху.
Можно также задавать положение ключевыми словами. В этом случае порядок значений не важен. Ключевые слова для вертикали:
top, center, bottom. Ключевые слова по горизонтали: left, center, right.
селектор {
background-position: два значения через пробел;
}

🚩Свойство background-size задает размер картинки фона. Значением свойства служат любые единицы для размеров, либо
ключевые слова auto, cover или contain.

селектор { background-size: значение; } auto->по умолчанию

auto Фон будет иметь натуральный размер, такой, как реальный размер картинки фона. Если же auto задано только для одной
стороны, то по этой стороне фон будет масштабироваться так, чтобы иметь неискаженные пропорции.
cover Масштабирует картинку так, чтобы она накрыла собой весь блок с сохранением пропорций. Картинка будет стараться
поместиться целиком, но это не всегда будет получаться, поэтому какая-то ее часть будет обрезаться. Блок всегда будет
покрыт картинкой целиком.
contain Масштабирует картинку так, чтобы она целиком влезла в блок с сохранением пропорций. При этом она может занять
или всю ширину, или всю высоту (зависит от пропорций картинки и от размеров элемента). Блок в общем случае будет покрыт
картинкой не целиком (зато картинка всегда будет видна вся, хоть и в уменьшенном варианте).

.header__content{
background-image: url('../images/header-bg.jpg');
background-repeat: no-repeat;
background-position: center;
background-size: cover;
min-height: calc(100vh - 94px);
}

---------------------------------------------section-------------------------------------------

Если делать блок section-то обязательно должен быть тег от <h1> до <h2> хотя бы один.

---------------------------------------------column-count-------------------------------------------

Свойство column-count задает рекомендуемое количество колонок в многоколоночном тексте. Их реальное количество может
отличаться от заданного, в зависимости от ширины колонки и размера промежутка между ними.

селектор {
column-count: число | auto;
}

число Задает указанное количество колонок. Точнее, рекомендует браузеру использовать это количество колонок, так как их
реальное количество может отличаться от заданного, в зависимости от ширины колонки и размера промежутка между ними.
auto Браузер сам подбирает оптимальное количество колонок.

---------------------------------------------Специфичность css-------------------------------------------
html
<div id="index" class="test"></div>
css


читать css снизу вверх
---------------------------------------------------------------
Правило !importantв CSS используется для придания свойству/значению большей важности, чем обычно(❗Наивысший приоритет).

Фактически, если вы используете это !importantправило, оно переопределит ВСЕ предыдущие правила стилизации для этого конкретного свойства этого элемента!
.test{ background: #ccc !important; }

Если написать инлаин стили, то будет 1000 баллов. Он имеет наивысший приоритет. Пишутся инлаин стили в теге который находиться в html.
/* 1.0.0.0 */
<div id="index" class="test" style="background: #000; width: 100px;height: 100px;"></div>
/* 0.1.0.0 */
Если написать обращение по идентификатору, то будет 100 баллов
❗Но идентификатор можно использовать только один на странице и он должен быть уникальным.
/* 0.1.0.0 */
#index { background: #ccc; }
если написать обращение по классу к тегу то соответственно
будет 11 баллов
/* 0.0.1.1 */
.body div{ background: #ccc; }
если написать обращение по классу к классу то соответственно
будет 20 баллов
/* 0.0.2.0 */
.body .test{ background: #ccc; }
Это все мишура обращение по классу дает 10 баллов
/* 0.0.1.0 */
.test{ background: #ccc; }
Это обращение по тегу к вложенному тегу дает 1 балл плюс 1 балл равно 2 бала. Если будет тройная вложенность то будет 3
балла
/* 0.0.0.2 */
body div{ background-color: red; }

Это обращение по тегу дает 1 балл
/* 0.0.0.1 */
div{ background-color: blue; }

В классах то свойство которое ниже будет иметь больший приоритет чем которое выше. Это есть специфичность. Она не такая
простая. За это все есть баллы
---------------------------------------------------------------
/* 0.0.1.0 */
.test{
width: 200px;
height: 200px; background-color:
background: #ccc;
}

.test{
background: #000;
}
---------------------------------------------Текст в верхнем индексе sup-------------------------------------------

Тег sup отображает текст в верхнем индексе, то есть чуть выше линии обычного текста и шрифтом меньшего размера. Это бывает нужно для записи математических или химических формул и так далее.
Формула квадратного уравнения: ax<sup>2</sup> + bx + c = 0.

---------------------------------------------Псевдоэлемент ::placeholder-------------------------------------------
Псевдоэлемент, с помощью которого задаётся стилевое оформление подсказывающего текста, созданного атрибутом placeholder. Допускается использовать свойства для изменения вида текста, например, задать шрифт и цвет.

Пример:
.form input::placeholder{
font-size: 12px;
line-height: 20px;
letter-spacing: 3.71px;
text-transform: uppercase;
color: #B8B8B8;
}

---------------------------------------------Размеры текстового поля .textarea {resize: none}-------------------------------------------

Указывает, можно ли пользователю изменять размеры текстового поля.Применяется	К <textarea> или к любому элементу, у которого свойство overflow отличается от visible
Пример:
.form textarea {
min-height: 140px;
resize: none;
}






















































































































































Полезные ссылки:

1. Рыбные картинки
   https://dummyimage.com/
2. CSS reset
   http://html5doctor.com/html-5-reset-stylesheet/
3. Справочник
   https://webref.ru/
4. Шпаргалка по флексам -
   https://habr.com/ru/post/313938/
5. тренажер по флексам
   https://the-echoplex.net/flexyboxes/
6. Slick Slider -
   https://kenwheeler.github.io/slick/
7. normalize:
   https://necolas.github.io/normalize.css/
8. Название классов:
   https://github.com/yoksel/common-words
9. emmet сокращения:
   https://docs.emmet.io/abbreviations/syntax/
10. Google шрифты:
    https://fonts.google.com
11. MixItUp -кнопки фильтра:
    https://www.kunkalabs.com/mixitup/
12. fancybox -для открытия видео:
    https://fancyapps.com/fancybox/3/
    https://daruse.ru/podklyuchenie-i-nastrojka-fancybox


